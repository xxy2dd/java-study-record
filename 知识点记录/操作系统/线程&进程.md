### 1. 什么是线程和进程？
* **进程**：程序的一次执行过程，是系统运行程序的基本单位。系统运行一个程序就是一个进程从创建到运行到消亡的过程，它是动态的。
  * 具体举例： Java 中的 main 函数；任务管理器查看运行的进程
* **线程**：比进程更小的执行单位。一个进程在执行过程中可以产生很多线程。
  与进程不同的是同类的多个线程共享进程的**堆和方法区资源**，但每个线程有自己的**程序计数器、虚拟机栈和本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。java 程序时多线程程序
* Java 中可以通过 JMX 的 threadMXBean 查看线程

### 2. 进程和线程的关系
线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反

**知识扩展**

1. 程序计数器
    作用是（1）按顺序读取指令（2）记录当前线程执行的位置（用于多线程）
    需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。
2. 虚拟机栈和本地方法栈
* 虚拟机栈：存放局部变量表、操作数栈、常量池引用等信息，为虚拟机执行Java方法服务
* 本地方法栈：为虚拟机使用到的 native 方法服务
3. 堆和方法区
    是同一进程中的所有线程共享的资源，堆最大，主要存放已被加载的类的信息、常量、静态变量、即时编译器编译后的代码等数据

### 3. 并发和并行
* 并发：同一时间段，多个任务都在执行
* 并行：单位时间内，多个任务同时执行

### 4. 线程的几种状态
* new
* runnable
* blocked
* waiting
* time_waiting
* terminated

**补充： 线程的实现**

* 实现 Runnable 接口（通过 Thread 调用 start() 启动线程）
* 实现 Callable 接口（JDK1.5 新增，可以有返回值）
* 继承 Thread 类（也实现了 Runnable 接口）
  考虑到 Java 不支持多继承的特点，所以如果类需要继承其他类则考虑实现 Runnable 接口
  **start() 启动线程，内部调用 run() 方法，但如果直接调用 run() 方法，不会启动新线程**

### 5. 死锁
1. 发生条件
* 互斥：任一时刻只有一个线程使用该资源
* 请求与保持：
  一个进程因请求资源而阻塞时，对已获得的资源保持不放。
* 不剥夺：
  线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
* 循环等待：
2. 如何避免
避免死锁最简单的方法就是**阻止循环等待**条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁
### 6. 线程安全
多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。

在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。假设某个线程把数据处理到一半，觉得很累，就去休息了一会，回来准备接着处理，却发现数据已经被修改了，不是自己离开时的样子了。可能被其它线程修改了
在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。

实现方式：
1. 不可变
    eg. final 关键字修饰；String；枚举类型；Number 部分子类，Long Double BigInteger BigDecimal；Collections.unmodifiableXXX() 使集合不可变

2. 互斥同步 （阻塞同步）
    eg. synchronized（JVM实现）  ReentrantLock（JDK实现）

3. 非阻塞同步
    eg. CAS AtomicInteger ABA

4. 无同步方案
    eg. 栈封闭  线程本地存储( ThreadLock )  可重入代码

**补充**：
1. 为什么 String 用 final 修饰？
> final 修饰使 String 不可变，作用：1.缓存hash值（高效）2.String Pool需要（即共享）3.安全性 4.线程安全


### 7. 线程池: 
概念 ： 在程序启动时就开辟一块空间，存在一些线程，执行调度由池管理器处理，有任务就取出，执行完归池。

1）**避免线程的创建和销毁带来的性能开销**。
2）避免大量的线程间因互相抢占系统资源导致的阻塞现象。
3｝能够对线程进行简单的管理并提供定时执行、间隔执行等功能。

组成：ThreadPool 、WorkThread 、Task 、taskQueue

创建线程池所需参数：
corePoolSize(线程池基本大小) maximumPoolSize(线程池最大大小) runnableTaskQueue(任务队列) 
TheadFactory

提交任务：execute() [重写run方法]或者 submit()

Executor: 
1. CachedThreadPool ：可缓存线程池
* 线程数无限制有空闲线程则复用空闲线程，若无空闲线程则新建线程 
* 一定程序减少频繁创建/销毁线程，减少系统开销
2. FixedThreadPool：定长线程池
* 可控制线程最大并发数（同时执行的线程数）
* 超出的线程会在队列中等待
3. SingleThreadExecutor：单线程化的线程池
* 有且仅有一个工作线程执行任务
* 所有任务按照指定顺序执行，即遵循队列的入队出队规则
4. ScheduledThreadPool：定时线程池
* 支持定时及周期性任务执行

新建线程 -> 达到核心数 -> 加入队列 -> 新建线程（非核心） -> 达到最大数 -> 触发拒绝策略

四种拒绝策略
1. AbortPolicy：不执行新任务，直接抛出异常，提示线程池已满，线程池默认策略

2. DiscardPolicy：不执行新任务，也不抛出异常，基本上为静默模式

3. DisCardOldSetPolicy：将消息队列中的第一个任务替换为当前新进来的任务执行

4. CallerRunPolicy：用于被拒绝任务的处理程序，它直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。

### 补充：数据库连接池
* 创建数据库连接非常耗时
* 连接数 = ((核心数 * 2) + 有效磁盘数)
* 项目中采用 HikariCP 连接池，是目前最快的连接池。除此之后常用的连接池还有C3P0、DBCP、tomcat-jdbc、druid
* 参数设置
    * maxLifetime : 控制池中连接的最大生存期，默认值30min，可设置比默认值短一些
    * minimumIdle：池中维护的最小空闲连接数
    * maximumPoolSize：池中允许达到的最大大小包括空闲和正在使用的连接
    * connectionTestQuery
 * 项目中的问题：
    Hikaricp 连接池获取不到连接数而连接不到数据库，导致请求失败
    connectionTimeout 采用默认值 30s，应该不会有太大问题。maximumPoolSize 根据业务量的设置，不会有太大问题。maxLifetime 如果过长，且 idleTimeout 没有时间限制时，会导致连接数很大，空闲连接一直得不到释放，严重挤占资源，容易引起连接数不够的问题。特别是 maxLifetime 如果大于数据库超时时长，就会抛出数据库连接异常，这也是本次生产问题所在：maxLifetime 设置成30分钟，超过了数据库连接时长 15 分钟，connectionTimeout 为 30 秒，所以每次异常都是在15分30秒抛出，数据库端已经收到Hikaricp连接请求，但是因网络问题等因素，到达超时时长而没有获取到连接。idleTimeout 只有在 minimumIdle 设置为小于maximumPoolSize 的情况下才生效，而我没有设置最小空闲连接数 minimumIdle 的值，minimumIdle 默认是等于 maximumPoolSize，此时 idleTimeout 不受限，空闲连接一直没有得到回收，出于系统优化以及并发稳定性考虑，应该增加此配置。

1. 连接空闲时间 idleTimeout 生效，根据业务请求重发频率为 40 多秒，值可设为 1 分钟，减少空闲连接占用，尽快释放数据库连接
2. 连接生命周期 maxLifetime 值设为10分钟，低于数据库超时时长，尽快释放数据库无效连接

### 8. 通信

#### 进程通信

* **管道**：无名、单向，只用于父子进程或兄弟进程，必须一个在写，一个在读
* **命名管道**：名字存放在文件系统中，内容放在内存中，可实现任意两个进程通信
* **消息队列**：
* **信号量**：P（阻塞）V（唤醒） 原语
* **信号**：Linux 中使用
* **共享存储**：直接读写内存，最快
* **套接字**：socket

#### 线程通信

* wait()  notify()
* join()
* volatile 共享内存

**补充**

* 交替打印奇数偶数
  * wait()  notify()   基于synchronized
  * Semaphore
  * ArrayBlockingQueue
  * Condition



